[[top-hits]]
=== field의 축약

특정 field로 그룹화된 검색 결과를 보여주는 것이 일반적인 요구 사항이다.((("field collapsing")))((("relationships", "field collapsing")))
사용자의 이름으로 _그룹화된_ 가장 관련 있는 블로그 게시물을 검색해 보자. ((("terms aggregation")))((("aggregations", "field collapsing"))) 
이름으로 그룹화하는 것은 `terms` aggregation 이 필요하다는 의미이다.  
<<aggregations-and-analysis>>에서 설명했듯이, 사용자의 전체 이름으로 그룹화하려면,
name field 는 원래의 `not_analyzed` 형태로 사용할 수 있어야 한다.

[source,json]
--------------------------------
PUT /my_index/_mapping/blogpost
{
  "properties": {
    "user": {
      "properties": {
        "name": { <1>
          "type": "string",
          "fields": {
            "raw": { <2>
              "type":  "string",
              "index": "not_analyzed"
            }
          }
        }
      }
    }
  }
}
--------------------------------
<1> `user.name` field 는 full-text 검색에 사용된다.
<2> `user.name.raw` field 는 `terms` aggregation에서 그룹화하는데 사용된다.

그 다음에, 데이터를 추가한다.

[source,json]
--------------------------------
PUT /my_index/user/1
{
  "name": "John Smith",
  "email": "john@smith.com",
  "dob": "1970/10/24"
}

PUT /my_index/blogpost/2
{
  "title": "Relationships",
  "body": "It's complicated...",
  "user": {
    "id": 1,
    "name": "John Smith"
  }
}

PUT /my_index/user/3
{
  "name": "Alice John",
  "email": "alice@john.com",
  "dob": "1979/01/04"
}

PUT /my_index/blogpost/4
{
  "title": "Relationships are cool",
  "body": "It's not complicated at all...",
  "user": {
    "id": 3,
    "name": "Alice John"
  }
}
--------------------------------

이제 John이라는 사용자로, `relationships`에 대한 블로그 게시물을 검색하기 위해, query를 실행할 수 있다. 
그리고, {ref}/search-aggregations-metrics-top-hits-aggregation.html[`top_hits` aggregation]를 이용해, 결과를 사용자로 그룹화할 수 있다.

[source,json]
--------------------------------
GET /my_index/blogpost/_search?search_type=count <1>
{
  "query": { <2>
    "bool": {
      "must": [
        { "match": { "title":     "relationships" }},
        { "match": { "user.name": "John"          }}
      ]
    }
  },
  "aggs": {
    "users": {
      "terms": {
        "field":   "user.name.raw",      <3>
        "order": { "top_score": "desc" } <4>
      },
      "aggs": {
        "top_score": { "max":      { "script":  "_score"           }}, <4>
        "blogposts": { "top_hits": { "_source": "title", "size": 5 }}  <5>
      }
    }
  }
}
--------------------------------
<1> `search_type=count`로 설정하여, 일반적인 검색 `hits`를 비활성화하였기 때문에, 
    관심을 가지고 있는 블로그 게시물은 `blogposts` aggregation 아래로 반환된다. 
<2> `query`는 `John`이라는 이름의 사용자가 작성한 `relationships`에 대한 블로그 게시물을 반환한다.
<3> `terms` aggregation은 각 `user.name.raw` 값에 대한 bucket을 생성한다.
<4> `top_score` aggregation 은 각 bucket의 상위 score를 가진 document로, users aggregation 내에서 terms를 정렬한다.
<5> `top_hits` aggregation은 각 user 에 대해 가장 관련 있는 5개의 블로그 게시물의 `title` field 만을 반환한다.

응답은 다음과 같다.

[source,json]
--------------------------------
...
"hits": {
  "total":     2,
  "max_score": 0,
  "hits":      [] <1>
},
"aggregations": {
  "users": {
     "buckets": [
        {
           "key":       "John Smith", <2>
           "doc_count": 1,
           "blogposts": {
              "hits": { <3>
                 "total":     1,
                 "max_score": 0.35258877,
                 "hits": [
                    {
                       "_index": "my_index",
                       "_type":  "blogpost",
                       "_id":    "2",
                       "_score": 0.35258877,
                       "_source": {
                          "title": "Relationships"
                       }
                    }
                 ]
              }
           },
           "top_score": { <4>
              "value": 0.3525887727737427
           }
        },
...
--------------------------------
<1> `search_type=count`로 설정했기 때문에, `hits` 배열은 비어있다.
<2> 상위 결과에 나타나는 각 user의 bucket이 있다. 
<3> 각 user의 bucket 아래에, 해당 사용자에 대한 상위 결과를 포함하는 `blogposts.hits` 배열이 있다.
<4> user bucket은 사용자와 가장 관련 있는 블로그 게시물에 의해 정렬된다.

((("top_hits aggregation")))`top_hits` aggregation을 사용하는 것은 
가장 관련 있는 블로그 게시물을 가진 사용자의 이름을 반환하는 query를 실행하고,
그 다음에 해당 사용자 최고의 블로그 게시물을 얻기 위해, 각각의 사용자에 대한 동일한 query를 실행하는 것과 동일하다. 
하지만 이것이 훨씬 더 효율적이다.

각 bucket에서 반환되는 상위 hits는 원래의 주 query를 기반으로 한, 가벼운 _mini-query_의 결과이다.
mini-query는 하이라이트(highlighting)와 페이지 계산(pagination)처럼, 검색에서 기대할 수 있는 일반적인 기능을 지원한다.
