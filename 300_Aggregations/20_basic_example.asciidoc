
== Aggregation Test-Drive

다음 몇 페이지에서, 다양한 aggregation과 그 문법에 대해 이야기할 것이다.((("aggregations", "basic example", id="ix_basicex")))
aggregation은 예제로 배우는 것이 제일 좋다.
aggregation에 대한 생각하는 방법과 적절하게 중첩시키는 방법을 배우기만 하면, 문법은 매우 간단하다.

[NOTE]
=========================
aggregation bucket과 metric 전체 목록은 {ref}/search-aggregations.html[Elasticsearch Reference]에서 찾을 수 있다.
이번 챕터에서 많은 부분을 다룰 것이지만, 전체 목록을 살펴본 이후에 모든 기능들에 대해 익숙해질 것이다.
=========================

그러니 들어가서, 예제를 시작해 보자.
자동차 판매상에게 유용한 몇 가지 aggregation을 만들어 볼 것이다.
데이터는 자동차 모델, 제조업체, 판매가, 언제 팔렸는지 등의 자동차 거래에 대한 것이다.

먼저, 작업에 사용할 약간의 데이터를 bulk-index 해보자.

[source,js]
--------------------------------------------------
POST /cars/transactions/_bulk
{ "index": {}}
{ "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" }
{ "index": {}}
{ "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" }
{ "index": {}}
{ "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" }
{ "index": {}}
{ "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" }
--------------------------------------------------
// SENSE: 300_Aggregations/20_basic_example.json

이제 데이터가 준비되었으니, 첫 번째 aggregation을 만들어보자.
자동차 판매상은 가장 잘 팔린 자동차가 어떤 색상인지 알고 싶어한다.
이것은 간단한 aggregation을 사용하여 쉽게 할 수 있다.
`terms` bucket을 사용할 것이다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "aggs" : { <1>
        "colors" : { <2>
            "terms" : {
              "field" : "color" <3>
            }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/20_basic_example.json

<1> aggregation은 ((("aggregations", "aggs parameter")))최상위 `aggs` 매개변수 아래에 위치한다. (원한다면 `aggregations` 매개변수를 사용해도 좋다.)
<2> 원하는 대로, aggregation의 이름을 붙인다. 이 예제에서는 `colors`이다.
<3> 마지막으로 `terms` type의 단일 bucket을 정의한다.

검색 결과에 관심이 없기 때문에, search_type=count을 더 빠른, count로 사용한다.

aggregation은 검색 결과의 문맥 안에서 실행된다.((("searching", "aggregations executed in context of search results"))) 즉, 검색 요청(예를 들어, 마지막에 `_search` endpoint를 사용하는)의 또 다른 최상위 단계 매개변수이다. aggregation는 query와 결합할 수 있다. 이것은 나중에 <<scoping aggregations>> 에서 이야기 할 것이다

[NOTE]
=========================
`count` <<search-type,search_type>>을 사용한 것을 볼 수 있다.((("count search type")))
검색 결과는 관심 대상이 아니기 때문에, fetch 단계를 생략해 `count` search_type은 더욱 빠르게 동작하게 된다.
=========================

다음으로 aggregation에 대한 이름을 정의한다. 이름은 여러분이 결정하면 된다. 나중에 응용 프로그램이 결과를 분석할 수 있도록, 응답은 여러분이 제공한 이름으로 표시될 것이다.

다음으로 aggregation 그 자체를 정의한다. 이 예에서, 단일 terms bucket을 정의하고 있다.((("buckets", "terms bucket (example)")))((("terms bucket", "defining in example aggregation"))) terms bucket은 유일한 단어를 만날 때마다 동적으로 새로운 bucket을 생성한다. `color` field를 사용했기 때문에, terms bucket은 각 색상에 대해 동적으로 새로운 bucket을 생성한다.

aggregation을 실행하고, 그 결과를 살펴보자.

[source,js]
--------------------------------------------------
{
...
   "hits": {
      "hits": [] <1>
   },
   "aggregations": {
      "colors": { <2>
         "buckets": [
            {
               "key": "red", <3>
               "doc_count": 4 <4>
            },
            {
               "key": "blue",
               "doc_count": 2
            },
            {
               "key": "green",
               "doc_count": 2
            }
         ]
      }
   }
}
--------------------------------------------------
<1> `search_type=count` 매개변수를 사용했기 때문에, 검색 결과는 반환되지 않는다.
<2> `colors` 집계는 `aggregations` field의 일부로 반환된다.
<3> 각 bucket의 key는 `color` field에서 발견한 유일한 단어에 해당한다. 또한 해당 단어를 가지고 있는 document의 수를 나타내는 doc_count를 항상 포함한다.
<4> 각 bucket의 수는 해당 색상의 document 수를 나타낸다.

((("doc_count")))응답은 bucket 목록을 포함하고 있고, 각 bucket은 단일 색상(red, green 등)에 상응한다. 또한 각 bucket은 특정 bucket에 해당하는 document의 수를 포함한다. 예를 들면, 붉은 색상의 자동차는 4대가 있다.

위의 예는 완전히 실시간으로 작동한다. document가 검색이 가능하면, aggregation도 가능하다. 즉 aggregation 결과를 실시간으로 대시보드를 생성하는 그래프 라이브러리에 즉시 보낼 수 있다. 은색 자동차를 팔자마자 은색 자동차에 대한 통계를 포함하도록 그래프는 동적으로 업데이트될 것이다.

짜짠! 첫 번째 aggreation은 여기까지이다.
((("aggregations", "basic example", startref ="ix_basicex")))
