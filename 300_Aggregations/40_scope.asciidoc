
[[_scoping_aggregations]]
== Scoping Aggregations

지금까지의 aggregation 예제에서는, 검색 요청에서 `query`가 생략되었다.((("queries", "in aggregations")))((("aggregations", "scoping"))) 전체 요청은 단순한 aggregation이었다.

Aggregation은 검색 요청과 동시에 실행될 수 있다. 이를 위해 새로운 개념인 _scope_(범위)를 이해해야 한다.((("scoping aggregations", id="ix_scopeaggs", range="startofrange"))) 기본적으로 aggregation은 query와 동일한 범위에서 동작한다. 다시 말해 aggregation은 query에 일치하는 document의 집합에서 계산된다.

첫 번째 aggregations 예제 중 하나를 살펴 보자.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color"
            }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/40_scope.json

Aggregation은 독립적임을 알 수 있다. 실제로 Elasticsearch는 “어떤 query도 지정되지 않았다”는 것은 “모든 document를 query 했다”와 동등하다고 가정한다. 위의 query는 내부적으로 아래와 같이 변경된다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query" : {
        "match_all" : {}
    },
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color"
            }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/40_scope.json

Aggregation은 언제나 query의 범위 내에서 동작한다. 따라서 독립된 aggregation은 실제로 ((("match_all query", "isolated aggregations in scope of")))`match_all` query의 범위(즉, 모든 document) 내에서 동작한다.

Scoping를 이해했다면, 사용자 정의 aggregation을 시작할 수 있다. 이전의 예제 모두는 모든 데이터에 대한 통계(가장 많이 팔린 자동차, 모든 자동차의 평균 가격, 월별로 가장 많이 팔린 자동차 등)를 계산하였다.

범위를 이용하면, “나와 있는 Ford 자동차에 어떤 색상이 있나요?”같은 질문을 할 수 있다. 간단하게, 요청에 query(이 경우에는 `match` query)를 추가하면 된다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search  <1>
{
    "query" : {
        "match" : {
            "make" : "ford"
        }
    },
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color"
            }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/40_scope.json
<1> ((("search_type", "count"))) 검색 hit를 반환하기 위해, `search_type=count`를 생략하였다.

`search_type=count`를 생략하였기 때문에, 검색 결과와 집계 결과를 모두 볼 수 있다.

[source,js]
--------------------------------------------------
{
...
   "hits": {
      "total": 2,
      "max_score": 1.6931472,
      "hits": [
         {
            "_source": {
               "price": 25000,
               "color": "blue",
               "make": "ford",
               "sold": "2014-02-12"
            }
         },
         {
            "_source": {
               "price": 30000,
               "color": "green",
               "make": "ford",
               "sold": "2014-05-18"
            }
         }
      ]
   },
   "aggregations": {
      "colors": {
         "buckets": [
            {
               "key": "blue",
               "doc_count": 1
            },
            {
               "key": "green",
               "doc_count": 1
            }
         ]
      }
   }
}
--------------------------------------------------

이것은 사소해 보일 수도 있지만, 진보되고 강력 대시보드의 핵심이다. 검색 창을 추가하여 정적 대시보드를 실시간 데이터 탐색 장치로 변환할 수 있다.((("dashboards", "adding a search bar"))) 이것은 사용자가 단어를 검색해 실시간으로 업데이트되는 graph(aggregation으로 강화하고, query로 범위를 지정한)의 모든 것을 볼 수 있도록 한다. Hoodop으로 이것을 시도해보라! (쉽지 않을 것이다.)

[float]
=== Global Bucket

대부분 query에 범위를 지정한 aggregation을 원한다. 하지만 가끔 데이터의 일부를 검색하면서, 데이터 전체에 대한 aggregation이 필요한 경우가 있다.

예를 들어, Ford 자동차의 평균 가격과 전체 자동차의 평균 가격을 비교하려 한다고 가정해 보자. 첫 번째 정보를 얻기 위해, 일반적인 aggregation(query로 범위를 지정한)을 사용할 수 있다. 두 번째 정보는 ((("buckets", "global")))((("global bucket"))) `global` bucket을 사용하여 얻을 수 있다.

+global+ bucket은 query 범위에 관계없이(완전히 범위를 무시한다.), document 모두를 포함한다. 그것은 bucket이기 때문에, 다른 것과 마찬가지로 그 안에 aggregation을 중첩할 수 있다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query" : {
        "match" : {
            "make" : "ford"
        }
    },
    "aggs" : {
        "single_avg_price": {
            "avg" : { "field" : "price" } <1>
        },
        "all": {
            "global" : {}, <2>
            "aggs" : {
                "avg_price": {
                    "avg" : { "field" : "price" } <3>
                }

            }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/40_scope.json
<1> 이 aggregation은 query의 범위 내(+ford+에 일치하는 모든 document)에서 동작한다.
<2> global bucket은 매개변수를 가지지 않는다.
<3> 이 집계는 제조업체에 관계없이 모든 document에 대해 동작한다.

+single_avg_price+ metric은 query 범위(모든 +ford+ 자동차)내 모든 document를 기반으로 계산한다. +avg_price+ metric은 global bucket 아래에 중첩된다. 즉, 범위를 완전히 무시하고, 모든 document를 계산한다. 해당 aggregation에 대해 반환되는 평균은 모든 자동차의 평균을 나타낸다.

지금까지 이 책을 읽어오면서, “가능한 한 모든 곳에서 filter를 사용하자” 라는 문구를 기억할 것이다. aggregation에서도 마찬가지이다. 다음 장에서 query의 범위를 제한하는 대신, aggregation에 filter를 적용하는 방법에 대해 이야기할 것이다.((("scoping aggregations", range="endofrange", startref="ix_scopeaggs")))
