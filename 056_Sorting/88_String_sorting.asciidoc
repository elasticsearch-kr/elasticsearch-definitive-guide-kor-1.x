[[multi-fields]]
=== 문자열 정렬과 다중 field

분석된 string field 또한 다중 값 field이다. ((("strings", "sorting on string fields")))((("analyzed fields", "string fields")))((("sorting", "string sorting and multifields"))) 그러나 그것들을 정렬해 보면, 거의 원하는 결과가 나오지 않는다. `fine old art` 를 분석해 보면, 3개의 단어가 나온다. 아마도 ABC순으로 첫 번째 단어로, 그 다음에 두 번째 단어로 정렬되기를 기대할 것이다. 그러나, Elasticsearch는 정렬 시에, 이런 처리에 대한 정보를 가지고 있지 않다.

`min` (기본) 또는 `max` sort mode를 사용할 수 있으나, 의도했던 것이 아닌, `art` 나 `old` 로 정렬될 것이다.

string field를 정렬하기 위해서는, 그 field 전체가 `not_analyzed` string인, 단 하나의 단어만을 포함하고 있어야 한다.((("not_analyzed string fields", "sorting on"))) 그러나, 물론 full-text로 query할 수 있도록 하기 위해, 해당 field는 `analyzed` 이어야 한다.

////
In order to sort on a string field, that field should contain one term only:
the whole `not_analyzed` string.((("not_analyzed string fields", "sorting on")))  But of course we still need the field to be
`analyzed` in order to be able to query it as full text.
////

두 가지 방법으로 동일한 string을 색인하는 단순한 접근은, document에 두 개의 분리된 field (검색을 위한 `analyzed` field, 정렬을 위한 `not_analyzed` field)를 포함하는 것이다.

그러나, 동일한 string을 `_source` field에 두 번 저장하는 것은 디스크 낭비이다. 가장 좋은 방법은 _2개의 다른 방법으로 색인_ 하지 않고, _단일 field_ 에 색인 하는 것이다. 모든 기본 field type(string, number, boolean, date)은 `fields` 매개변수를 통해, 단순한 mapping을 다중 field mapping으로 변경할 수 있다.

////
But  storing the same string twice in the `_source` field is waste of space.
What we really want to do is to pass in a _single field_ but to _index it in two different ways_. All of the _core_ field types (strings, numbers,
Booleans, dates) accept a `fields` parameter ((("mapping (types)", "transforming simple mapping to multifield mapping")))((("types", "core simple field types", "accepting fields parameter")))((("fields parameter")))((("multifield mapping")))that allows you to transform a
simple mapping like
////

[source,js]
--------------------------------------------------
"tweet": {
    "type":     "string",
    "analyzer": "english"
}
--------------------------------------------------

////
into a _multifield_ mapping like this:
////

[source,js]
--------------------------------------------------
"tweet": { <1>
    "type":     "string",
    "analyzer": "english",
    "fields": {
        "raw": { <2>
            "type":  "string",
            "index": "not_analyzed"
        }
    }
}
--------------------------------------------------
// SENSE: 056_Sorting/88_Multifield.json

<1> `tweet` field는 전과 같이 `analyzed` full-text field 이다. 
<2> `tweet.raw` 라는 새로운 하위 field는 `not_analyzed` 이다.

이제, 데이터를 다시 색인하면, 검색에는 `tweet` field를, 정렬에는 `tweet.raw` field를 사용할 수 있다.

[source,js]
--------------------------------------------------
GET /_search
{
    "query": {
        "match": {
            "tweet": "elasticsearch"
        }
    },
    "sort": "tweet.raw"
}
--------------------------------------------------
// SENSE: 056_Sorting/88_Multifield.json

    
WARNING: full-text `analyzed` field를 정렬하는 것은 많은 메모리가 필요하다. <<fielddata-intro>> 를 참조하자.

