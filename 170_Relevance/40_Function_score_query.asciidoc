[[function-score-query]]
=== function_score Query

{ref}/query-dsl-function-score-query.html[`function_score` query] 는
score 계산 프로세스를 제어할 수 있는 최고의 도구이다.
((("function_score query")))((("relevance", "controlling", "function_score query")))
원래 query 의 `_score` 를 변경하거나, 완전히 대체하기 위하여,
query 에 일치하는 각 document 에 function 을 적용할 수 있다.

사실, filter 를 사용하여 주요 결과의 _부분 집합_ 에 다른 function 을 적용할 수 있다.
이것은 cache 를 이용할 수 있는 filter 로 효율적인 score 계산이 가능하다.

아래에, 미리 정의된 몇 가지 function 이 있다.

`weight`::

    정규화된 가중치(boost)없이, 각 document에 간단한 가중치를 적용한다.
    `weight` 가 `2` 이면, 결과는 `2` * `_score`.

`field_value_factor`::

    `_score` 를 변경하기 위하여, document 에 있는 field 의 값을 사용한다.
    `인기 투표` 의 `수` 등을 고려할 때 사용

`random_score`::

    document 가 동일한 score 를 가지고 있으나, 서로 다른 사용자에게 무작위로 보여지고,
    각 사용자에 대해 동일한 정렬을 유지한다는 것을 보장하기 위하여, 결과에 일관된 무작위 정렬을 적용한다.

_Decay functions_&#x2014;`linear`, `exp`, `gauss`::

    최근에 쓰여진 document, 가까운 곳에 위치한 document,
    지정된 가격대 근처의 document 를 위하여, `쓰여진 날짜`, `위치정보`, `가격` 같은 값을
    차등적으로 `_score` 에 통합한다.

`script_score`::

    scoring logic 의 완벽한 제어를 위하여, 사용자 정의 script 를 사용한다.
    위에 나열된 것 이상의 확장된 function 이 필요하다면,
    필요한 logic 을 구현하기 위하여 사용자 정의 script 를 작성한다.

`function_score` query 없이, 최근 document 같은 요소를 full text query 의 score 와 조합할 수 없다.
`_score` 나 `date` 로 정렬할 수 밖에 없다. 한쪽의 효과는 다른 쪽의 효과를 지워버린다.
이 query 는 두 개를 같이 조합할 수 있다. 여전히 full text relevance 로 정렬하면서,
최근 document 나 인기 있는 document 또는 사용자의 가격대 근처의 상품에 추가로 가중치를 준다.
상상할 수 있겠지만, 위의 상황 모두를 지원하는 query 는 매우 복잡할 수 있다. 
간단한 적용 사례로 시작하여 복잡한 단계로 올라가 보자.
