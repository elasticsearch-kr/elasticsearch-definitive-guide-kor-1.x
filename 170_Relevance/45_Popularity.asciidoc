[[boosting-by-popularity]]
=== Boosting by Popularity - 인기에 따른 가중치 부여

사용자들이 자기가 좋아하는 블로그 게시물에 투표할 수 있는 블로그를 가진 website 를 가정해 보자.
((("relevance", "controlling", "boosting by popularity")))((("popularity", "boosting by")))
((("boosting", "by popularity")))
결과 목록에서 더 높게 나타나는 더 인기 있는 게시물을 좋아하겠지만,
여전히 relevance score 를 가져야 한다. 각 블로그 게시물의 투표 수를 저장하면, 간단하게 이것을 할 수 있다.

[role="pagebreak-before"]
[source,json]
-------------------------------
PUT /blogposts/post/1
{
  "title":   "About popularity",
  "content": "In this post we will talk about...",
  "votes":   6
}
-------------------------------

검색 시에, 투표 수와 full text relevance score 를 조합하기 위하여,
`field_value_factor` function 으로 `function_score` query
((("function_score query", "field_value_factor function")))((("field_value_factor function"))) 를 사용할 수 있다:

[source,json]
-------------------------------
GET /blogposts/post/_search
{
  "query": {
    "function_score": { <1>
      "query": { <2>
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": { <3>
        "field": "votes" <4>
      }
    }
  }
}
-------------------------------
<1> `function_score` query 는 적용할 main query 와 function 을 감싼다.
<2> main query 가 먼저 실행된다
<3> `field_value_factor` function 은 main `query` 에 일치하는 모든 document 에 적용된다.
<4> 모든 document 는 `function_score` 를 위해 `votes` field 를 _반드시_ 가지고 있어야 한다.

위의 예에서, 각 document 에 대한 최종 `_score` 는 아래처럼 변경된다.

    new_score = old_score * number_of_votes

위에서 좋은 결과가 나오지는 않을 것이다. full text `_score` 의 범위는 일반적으로 0 과 10 사이의 어디쯤일 것이다.
왜냐하면, 투표수가 10 인 블로그 게시물은 full text score 의 효과를 완전히 뒤덮을 것이고,
투표수가 0 인 게시물은 score 가 0 이 될 것이다.

[[img-popularity-linear]]
.Linear popularity based on an original `_score` of `2.0`
image::images/elas_1701.png[ 원래의 `_score` 가 `2.0` 인 경우 인기의 선 그래프 ]


==== modifier

인기를 통합하는 더 나은 방법은, 어떤 `modifier` 로 `votes` 값을 일정부분 제거하는 것이다.
((("modifier parameter")))((("field_value_factor function", "modifier parameter")))
즉, 처음 몇 번은 votes 를 많이 세고, 그 뒤의 votes 는 덜 세는 것이다.
votes 0 과 1 의 차이는 10 과 11 의 차이보다 훨씬 더 커야 한다.

이 예를 위한 대표적인 `modifier` 는 `log1p` 이다. 따라서 수식은 아래처럼 변경된다.

    new_score = old_score * log(1 + number_of_votes)

`log` function 은, 아래와 같은 곡선을 나타내기 위해, `votes` field 의 값을 일정 부분 제거한다.

[[img-popularity-log]]
.Logarithmic popularity based on an original `_score` of `2.0`
image::images/elas_1702.png[ 원래의 `_score` 가 `2.0` 인 경우 인기의 log 그래프 ]

`modifier` 매개변수를 이용한 요청은 아래와 같다:

[source,json]
-------------------------------
GET /blogposts/post/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field":    "votes",
        "modifier": "log1p" <1>
      }
    }
  }
}
-------------------------------
<1> `modifier` 에 `log1p` 를 설정.

[role="pagebreak-before"]
이용할 수 있는 modifier 에는 `none` (default), `log`, `log1p`, `log2p`, `ln`, `ln1p`,
`ln2p`, `square`, `sqrt` 그리고 `reciprocal` 이 있다.
{ref}/query-dsl-function-score-query.html#function-field-value-factor[`field_value_factor` documentation] 를 참고하자.

==== factor

어떤 숫자를 `votes` field 에 있는 값에 곱하여 ((("factor (function_score)")))
((("field_value_factor function", "factor parameter"))),
인기의 효과를 증가 또는 감소시킬 수 있는데, 이를 `factor` 라 한다.

[source,json]
-------------------------------
GET /blogposts/post/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field":    "votes",
        "modifier": "log1p",
        "factor":   2 <1>
      }
    }
  }
}
-------------------------------
<1> 인기의 효과를 두 배로 한다.

`factor` 를 추가하면, 수식은 아래와 같이 변경된다:

    new_score = old_score * log(1 + factor * number_of_votes)

`factor` 가 `1` 보다 크면 효과는 증가하고, `1` 보다 작으면 감소한다.

[[img-popularity-factor]]
.Logarithmic popularity with different factors
image::images/elas_1703.png[여러 가지 factor에 따른 인기의 log 그래프]


==== boost_mode

full text score 를 `field_value_factor` function ((("function_score query", "boost_mode parameter")))
((("boost_mode parameter"))) 의 결과와 곱하면, 효과가 너무 커질 수 있다.
`boost_mode` 매개변수를 사용하여, function 의 결과가 query 의 `_score` 와 조합되는 방법을 제어할 수 있다.
아래와 같은 값이 있다:

`multiply`::
      function 의 결과와 `_score` 를 곱한다. (기본값)

`sum`::
      function 의 결과에 `_score` 를 더한다.

`min`::
      function 의 결과와 `_score` 중 더 작은 값

`max`::
      function 의 결과와 `_score` 중 더 큰 값

`replace`::
      `_score` 를 function 의 결과로 대체한다.

곱하는 대신에, function 의 결과에 `_score` 를 더한다면,
특히나 낮은 `factor` 를 사용한다면 훨씬 더 작은 효과를 만들 수 있다.

[source,json]
-------------------------------
GET /blogposts/post/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field":    "votes",
        "modifier": "log1p",
        "factor":   0.1
      },
      "boost_mode": "sum" <1>
    }
  }
}
-------------------------------
<1> function 의 결과에 `_score` 를 더한다.

이제, 위의 요청에 대한 수식은 아래와 같다.

    new_score = old_score + log(1 + 0.1 * number_of_votes)

[[img-popularity-sum]]
.Combining popularity with `sum`
image::images/elas_1704.png["`sum` 을 사용한 인기의 조합"]

==== max_boost

마지막으로, `max_boost` 매개변수를 사용하여, function 이 가질 수 있는 최대 효과를
((("function_score query", "max_boost parameter")))((("max_boost parameter")))
제한할 수 있다:

[source,json]
-------------------------------
GET /blogposts/post/_search
{
  "query": {
    "function_score": {
      "query": {
        "multi_match": {
          "query":    "popularity",
          "fields": [ "title", "content" ]
        }
      },
      "field_value_factor": {
        "field":    "votes",
        "modifier": "log1p",
        "factor":   0.1
      },
      "boost_mode": "sum",
      "max_boost":  1.5 <1>
    }
  }
}
-------------------------------
<1> `field_vaule_factor` function 의 결과는 `1.5` 보다 클 수 없다.

NOTE: `max_boost` 는, 최종적이 `_score` 가 아닌, function 의 결과의 제한에만 적용한다.
