[[practical-scoring-function]]
=== Lucene's Practical Scoring Function - Lucene 의 실질적인 score 계산 함수

다중 단어 query 의 경우, Lucene 은 <<boolean-model,Boolean model>>,
<<tfidf,TF/IDF>> 그리고 <<vector-space-model,vector space model>> 을 가지고
((("relevance", "controlling", "Lucene&#x27;s practical scoring function", id="ix_relcontPCF", range="startofrange")))((("Boolean Model"))),
일치하는 document 를 수집하고 score 를 계산하는, 하나의 효율적인 패키지로 조합한다.

[source,json]
------------------------------
GET /my_index/doc/_search
{
  "query": {
    "match": {
      "text": "quick fox"
    }
  }
}
------------------------------

위의 다중 단어 query는, 내부적으로 아래와 같이 다시 작성된다:

[source,json]
------------------------------
GET /my_index/doc/_search
{
  "query": {
    "bool": {
      "should": [
        {"term": { "text": "quick" }},
        {"term": { "text": "fox"   }}
      ]
    }
  }
}
------------------------------

`bool` query는 boolean model 을 구현하는데,
이 경우에는, 단어 `quick` 이나 `fox` 를 가지고 있는 document 만을 포함한다.

document 가 query 에 일치하면, Lucene 은 각 일치하는 단어의 score 를 조합하여,
query 에 대한 score 를 계산한다.
score 를 계산하는데 사용되는 수식을 _practical scoring function_ 이라 한다.((("practical scoring function")))
약간 어려워 보이지만, 그렇지 않다. 대부분의 구성요소는 이미 알고 있다. 아래에서 몇 가지 새로운 요소를 소개하겠다.

................................
score(q,d)  =  <1>
            queryNorm(q)  <2>
          · coord(q,d)    <3>
          · ∑ (           <4>
                tf(t in d)   <5>
              · idf(t)²      <6>
              · t.getBoost() <7>
              · norm(t,d)    <8>
            ) (t in q)    <4>
................................

<1> `score(q, d)` 는 query `q` 에 대한 document `d` 의 relevance score 이다.
<2> `queryNorm(q)` 는 <<query-norm,_query normalization_ factor>> 이다. (new)
<3> `coord(q, d)` 는 <<coord,_coordination_ factor>> 이다. (new)
<4> document `d` 에 대한 query `q` 에서 각 단어 `t` 의 가중치의 합이다.
<5> `tf(t in d)` 는 document `d` 의 단어 `t` 에 대한 <<tf,term frequency>> 이다.
<6> `idf(t)` 는 단어 `t` 에 대한 <<idf,inverse document frequency>> 이다.
<7> `t.getBoost()` 는 query 에 적용된 <<query-time-boosting,_boost_>> 이다. (new)
<8> `norm(t, d)` 는, <<index-boost,index-time field-level boost>> – 색인 시 field에 가중치 부여로 조합된,
    <<field-norm,field-length norm>> 이다. [NEW]

`score`, `tf`, `idf` 는 알고 있을 것이다.
`queryNorm`, `coord`, `t.getBoost` 그리고 `norm` 은 새로운 개념이다.

이 장의 후반부에서, <<query-time-boosting,query-time boosting>> 에 대해 더 이야기할 것이다.
그러나, 먼저 query 정규화, 조정 그리고 색인 시의 field level boosting 에 대해 이야기해 보자.

[[query-norm]]
==== Query Normalization Factor - Query 정규화 요소

_query 정규화 요소_ (`queryNorm`) 는, 어떤 query 에서 나온 결과를 다른 결과와 비교하기 위해,
query 를 _정규화_ 하려는 ((("practical scoring function", "query normalization factor")))
((("query normalization factor")))((("normalization", "query normalization factor")))
시도이다.

[TIP]
==================================================

query norm 의 목적은 다른 query 의 결과와 비교하는 것이지만, 잘 동작하지 않는다.
실제로, relevance `_score` 의 유일한 목적은 현재 query 의 결과를 올바른 순서로 정렬하는 것이다.
다른 query 에서 relevance score 와 비교하려 해서는 안 된다.

==================================================

이 요소는 query 의 시작 부분에서 계산된다. 실제 계산은 포함된 query 에 따라 다르지만,
전형적인 구현은 아래와 같다:

..........................
queryNorm = 1 / √sumOfSquaredWeights <1>
..........................
<1> `sumOfSquaredWeights` 는 query 에 있는 각 단어의 IDF 를 모두 더한 후 제곱근을 구함으로써 계산된다.

TIP: 동일한 query 의 정규화 요소는 모든 document 에 적용되고, 변경할 수 있는 방법은 없다.
     모든 의도와 목적을 위해, 그것은 무시될 수 있다.

[[coord]]
==== Query Coordination - Query 조정

_조정(coordination) 요소_ (`coord`) 는, 높은 비율의 검색어를 포함하고 있는,
document에 대한 보상으로 사용된다((("coordination factor (coord)")))((("query coordination")))((("practical scoring function", "coordination factor"))).
document에 나타나는 검색어가 많을 수록, document가 query에 잘 일치할 기회가 더 커진다.

`quick brown fox` 를 검색하는데, 각 단어의 비중이 1.5 라고 가정해 보자.
조정요소가 없다면, score 는 document 에 있는 단어의 비중의 합일 것이다.
예를 들어:

* Document with `fox` -> score: 1.5
* Document with `quick fox` -> score: 3.0
* Document with `quick brown fox` -> score: 4.5

조정요소는 document 에서 일치하는 단어의 수를 score 에 곱하고, query 에 있는 단어의 총 수로 그것을 나눈다.
조정 요소를 반영한 score 는 아래와 같다:

* Document with `fox` -> score: `1.5 * 1 / 3` = 0.5
* Document with `quick fox` -> score: `3.0 * 2 / 3` = 2.0
* Document with `quick brown fox` -> score: `4.5 * 3 / 3` = 4.5

조정요소는, 3개 모두를 포함하고 있는 document 가, 2개의 단어만을 포함하고 있는 document 보다,
훨씬 더 많이 관련 있다는 결과로 나타난다.
`quick brown fox` 에 대한 query 는 아래의 `bool` query 처럼 다시 작성된다는 점을 기억하자:

[source,json]
-------------------------------
GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "term": { "text": "quick" }},
        { "term": { "text": "brown" }},
        { "term": { "text": "fox"   }}
      ]
    }
  }
}
-------------------------------

`bool` query 는, 기본적으로 모든 `should` 절에 대해, query 조정을 사용한다.
그러나, 조정을 비활성화할 수 있다.
왜 이렇게 해야 할까? 일반적으로 그 대답은 “그러지 않아도 된다” 이다.
query 조정은 일반적으로 좋은 것이다.
`match` query 같이 높은 수준의 query 를 감싸는 `bool` query 를 사용하는 경우,
조정을 활성화한 채로 두는 것이 합리적이다. 일치하는 절이 더 많을수록,
검색 요청과 반환되는 document 가 겹치는 정도가 더 높다.

그러나, 몇 가지 고급 사용 사례에서는 조정을 비활성화하는 것이 합리적이다.
동의어 `jump`, `leap`, `hop` 을 검색한다고 가정해 보자.
모두 동일한 의미를 나타내는 이들 동의어가 몇 번 나타나는가는 관심이 없다.
사실, 단 하나의 동의어만이 존재할 것이다. 이것은 조정 요소를 비활성화하는 좋은 예가 될 것이다.

[source,json]
-------------------------------
GET /_search
{
  "query": {
    "bool": {
      "disable_coord": true,
      "should": [
        { "term": { "text": "jump" }},
        { "term": { "text": "hop"  }},
        { "term": { "text": "leap" }}
      ]
    }
  }
}
-------------------------------

사실, 동의어(<<synonyms>>)를 사용할 때, 다시 작성된 query 는 동의어에 대해 조정을
비활성화하는 동작이 내부적으로 발생한다. ((("synonyms", "query coordination and")))
조정을 비활성화하는 대부분의 사용 사례는 자동으로 처리된다. 이에 대해 걱정할 필요가 없다.

[[index-boost]]
==== Index-Time Field-Level Boosting - 색인 시 Field 에 가중치 부여

아래 <<query-time-boosting>> 에서,
query 시에 field 에 _가중치_ 를 부여하는 것 -- 다른 field 보다
((("indexing", "field-level index time boosts")))((("boosting", "index time field-level boosting")))
((("practical scoring function", "index time field-level boosting")))
더 중요하게 만드는 것 -- 에 대해 이야기할 것이다.
색인 시에 field 에 가중치(boost)를 적용하는 것도 가능하다.
실제로 이 가중치는 field 자체보다는, field 에 있는 모든 단어에 적용된다.

필요한 것보다 더 많은 공간을 사용하지 않고 index 에 이 가중치 값을 저장하기 위해,​
색인 시의 field 가중치는 ((("field-length norm"))) field-length-norm 과
조합 (<<field-norm>>) 되고, index 에 단일 byte 로 저장된다.
이것이 위의 수식에서 `norm(t, d)` 에서 반환되는 값이다.

[WARNING]
=========================================

몇 가지 이유 때문에 색인 시에 field 가중치를 사용하는 것에 대해 강력하게 권고한다.

* 가중치를 field-length norm 과 조합하고, 그것을 단일 byte 로 저장하는 것은
  field-length norm 이 정확성을 잃는다는 것을 의미한다.
  결론적으로 Elasticsearch 는 3 단어를 가진 field 와 5 단어를 가진 field를 구분할 수 없다.
* 색인 시 가중치를 변경하기 위해, document 모두를 다시 색인 해야 한다.
  반면에, query 시 가중치는 각 query 마다 바꿀 수 있다.
* 색인 시 가중치를 가진 field가 다중 값이라면, 가중치는 모든 값에 대해 자신과 곱한다.
  해당 field 의 비중을 급격히 증가시킨다.

Query시 가중치 부여(<<query-time-boosting,Query-time boosting>>) 가 훨씬 더 간단하고 깔끔하고,
더 유연한 옵션이다.

=========================================

query 정규화, 조정과 색인 시 가중치 부여가 끝이 났으니,
relevance 계산에 영향을 끼치는 가장 유용한 도구인,
query 시 가중치 부여에 대해 알아보자.
((("relevance", "controlling", "Lucene&#x27;s practical scoring function", range="endofrange", startref="ix_relcontPCF")))
