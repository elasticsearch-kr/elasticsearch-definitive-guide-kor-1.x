[[script-score]]
=== Scoring with Scripts - Script 를 이용한 Score 계산

마지막으로, `function_score` 의 내장 함수 어느 것도 충분하지 않다면,
`script_score` function ((("function_score query", "using script_score function")))
((("script_score function")))((("relevance", "controlling", "scoring with scripts")))
을 사용하여, script 로 필요한 logic 을 구현할 수 있다.

예를 들어, relevance 계산에 이윤 폭(margin)을 반영하는 것을 가정해 보자.
사업에서 이윤 폭은 3가지 요소에 달려 있다.

* 여름용 별장의 1박당 가격(`price`)
* 사용자의 회원 단계(level) -- 특정 단계의 회원에게는, 1박당 특정 가격(`threshold`) 이상이면,
  일정 비율을 할인(`discount`)해 준다.
* 사용자 할인 후에, 1박당 가격의 일정 비율인 협상 가능한 이윤 폭(`margin`)

각 별장 별로 이윤을 계산하기 위해, 사용되는 알고리즘은 아래와 같다:

[source,groovy]
-------------------------
if (price < threshold) {
  profit = price * margin
} else {
  profit = price * (1 - discount) * margin;
}
-------------------------

순이익을 score 로 사용하지는 않을 것이다. 그럴 경우, 위치나 인기, 기능 같은 다른 요소를 무시하게 될 것이다.
대신, 목표(`target`) 이윤의 비율로 이윤을 나타낼 수 있다.
목표 이상의 이윤 폭은 +(positive, `1.0` 보다 큰) score 를 가질 것이고,
목표 이하의 이윤 폭은 –(negatice, `1.0` 보다 작은) score 를 가질 것이다.

[source,groovy]
-------------------------
if (price < threshold) {
  profit = price * margin
} else {
  profit = price * (1 - discount) * margin
}
return profit / target
-------------------------

Elasticsearch 에서 기본 script language 는 http://groovy.codehaus.org/[Groovy] 이다.
대부분의 경우, 이것은 javascript 처럼 보인다.
((("Groovy", "script factoring profit margins into relevance calculations")))
Groovy 로 위의 알고리즘을 나타내면, 아래와 같다:

[source,groovy]
-------------------------
price  = doc['price'].value <1>
margin = doc['margin'].value <1>

if (price < threshold) { <2>
  return price * margin / target
}
return price * (1 - discount) * margin / target <2>
-------------------------
<1> `price` 와 `margin` 변수는 document 의 `price` 와 `margin` field 에서 읽어온다.
<2> `threshold`, `discount`, `target` 변수는 `params` 으로 넘어온다.

마지막으로, `script_score` function 을 이미 사용했던 다른 function 의 목록에 추가할 수 있다.

[source,json]
-------------------------
GET /_search
{
  "function_score": {
    "functions": [
      { ...location clause... }, <1>
      { ...price clause... }, <1>
      {
        "script_score": {
          "params": { <2>
            "threshold": 80,
            "discount": 0.1,
            "target": 10
          },
          "script": "price  = doc['price'].value; margin = doc['margin'].value;
          if (price < threshold) { return price * margin / target };
          return price * (1 - discount) * margin / target;" <3>
        }
      }
    ]
  }
}
-------------------------
<1> `location` 과 `price` 절은 <<decay-functions>> 에서 설명한 예제를 참조하고 있다.
<2> `params` 로 이런 변수를 넘겨, script 를 다시 compile 하지 않고, 이 query 를 실행할 때 마다 이 값을 변경한다.
<3> JSON 은 내부에 newline 문자를 포함할 수 없다. javascript 에서 newline 문자는,
    `\n` 으로 escape 되거나 semicolon 으로 대체된다.

이 query 는 이윤을 봐야 하는 요구를 충족시키면서,
위치나 가격에 대한 사용자의 요구사항을 가장 만족시키는 document 를 반환한다.

[TIP]
========================================

`script_score` function 은 많은 유연성을 제공한다.((("scripts", "performance and")))
script 내에서 document 의 field, 현재 `_score`,
그리고 심지어 TF, IDF, field length norm({ref}/modules-advanced-scripting.html[Text scoring in scripts]) 까지 접근할 수 있다.

즉, script 는 성능에 영향을 줄 수 있다. 만약, script 가 충분히 빠르지 않다고 판단이 되면,
3가지 옵션을 선택할 수 있다.

* 가능한 한 많은 정보를 미리 계산하여, 각 document 가 그것을 포함하도록 하자.
* Groovy 는 빠르다. 그러나 Java 만큼 빠르지 않다.((("Java", "scripting in")))
  script 를 native java script 로 다시 구현해 보자. ({ref}/modules-scripting.html#native-java-scripts[Native Java Scripts] 참조).
* script 를 최고의 score 를 가진 document 에게만 적용되도록,
   <<rescore-api>> 에서 언급한 `rescore` 기능을 사용하자.

========================================
