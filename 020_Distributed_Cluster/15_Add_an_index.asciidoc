=== Index추가

Elasticsearch에 데이터를 추가하기 위해서는, 관련된 데이터를 저장할 수 있는 _index_&#x2014;저장소가 필요하다.
((("indices")))((("clusters", "index 추가하기"))) 실제로, index는 단지 하나 또는 그 이상의 물리적인 _shards_를 가리키는
_logical namespace_일 뿐이다.

_shard_는 index안에 있는 모든 data의 한조각만을 가진((("shards", "defined"))), low-level _worker unit_이다.
<<inside-a-shard>>에서 shard가 동작하는 방법에 대해 자세히 설명하겠지만,
지금은 각 shard가 Lucene의 single instance이고,
그 자체로 완벽한 검색 엔진이라는 것을 아는 것으로 충분하다.
document들은 shard에 저장되고, 색인된다. 그러나 응용프로그램들은 shard와 직접 이야기하지 않고,
대신에 index와 이야기한다.

shard는 Elasticsearch가 cluster로 데이터를 분산시키는 방법이다.
데이터 저장소로서 shard를 생각해 보자. document는 shard에 저장되고, shard는
cluster내 node에게 할당된다. cluster가 증가/감소함에 따라,
Elasticsearch는 cluster가 균형이 맞도록, 자동으로 node간에 shard를 이동시킨다.

shard는 _primary_ shard나 _replica_ shard가 될 수 있다. ((("primary shards")))((("replica shards")))((("shards", "primary")))
index에 있는 각각의 document는 단일 primary shard에 속한다. 그래서 primary shard의 수는
index가 가질 수 있는 데이터 양의 최대값을 결정한다.

[NOTE]
====
primary shard는 기술적으로 Integer.MAX_VALUE - 128 document까지 가질 수 있으며,
실질적인 한계는 사용 사례에 달려 있다: 가지고 있는 H/W, document의 크기나 복잡함,
document를 색인하고 검색하는 방법, 기대하는 응답 시간.
====

replica shard는 단순히 primary shard의 복사본이다.((("shards", "replica"))) replica는
H/W 장애로부터 데이터를 보호하기 위하여 복사본을 제공하고,
document를 검색하거나 가져오는 것과 같은, 읽기 요청을 처리한다.

index의 primary shard의 수는 index가 생성되는 시점에 결정된다.
그러나 replica shard의 수는 어느 때라도 변경할 수 있다.

비어있는 하나의 node를 가진 cluster에 `blogs`라 불리는 index를 생성해 보자.((("indices", "creating")))
기본적으로, index는 5개의 primary shard를 할당한다. ((("primary shards", "assigned to indices")))((("replica shards", "assigned to indices")))
그러나 여기서는 예제를 위해 3개의 primary shard와 1개의 replica를 할당하자. (각각의 primary shard에 대해 하나의 replica)

[source,js]
--------------------------------------------------
PUT /blogs
{
   "settings" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 1
   }
}
--------------------------------------------------
// SENSE: 020_Distributed_Cluster/15_Add_index.json

cluster는 이제 <<cluster-one-node>>처럼 보일 것이다. node 1에 모두 3개의 primary shard가 `Node 1`에 할당되었다.

[[cluster-one-node]]
.A single-node cluster with an index
image::images/elas_0202.png["하나의 index를 가진 단일 node cluster"]

만약 지금 상태에서 <<cluster-health,`cluster-health`>>를 확인해 보면, ((("cluster health", "checking after adding an index"))) 아래와 같이 나타날 것이다:

[source,js]
--------------------------------------------------
{
   "cluster_name":          "elasticsearch",
   "status":                "yellow", <1>
   "timed_out":             false,
   "number_of_nodes":       1,
   "number_of_data_nodes":  1,
   "active_primary_shards": 3,
   "active_shards":         3,
   "relocating_shards":     0,
   "initializing_shards":   0,
   "unassigned_shards":     3 <2>
}
--------------------------------------------------

<1> status file가 “yellow”이다. Cluster `status` is `yellow`.
<2> 3개의 replica shard가 node에 할당되지 않았다. Our three replica shards have not been allocated to a node.

cluster health에서 `yellow`는 모든 _primary_ shard가 올라와
실행 중인 것을 의미한다 (cluster가 모든 요청을 성공적으로 제공할 수 있다).
그러나, 모든 _replica_ shard가 Active인 것은 아니다. 사실, 3개의 모든 replica shard는
현재 `unassigned`&#x2014;되지 않았다(그들은 node에 할당되지 않았다).
동일한 node에, 동일한 데이터의 복사본을 저장하는 것은 말이 되지 않는다.
만약 해당 node를 잃어버리면, 우리는 데이터의 모든 복사본을 잃어버리게 된다.

현재, cluster는 모든 기능을 다하고 있지만, H/W 장애 시에는 데이터 분실의 위험이 있다.
